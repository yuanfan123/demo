# 1.消息保证百分之百投递
> 保证消息的成功发送

> 保障MQ节点的成功接收

> 发送端收到MQ节点（Broker）确认应答

> 完善消息补偿机制
## 1.1 解决方案
> 消息落库，对消息状态进行打标

>> 发消息的前先落库，发送后，获取相应并更新数据库
  
> 消息的延迟投递，做二次确认，回调检查

# 2.幂等性概念
1.执行很多次重复，结果是相同
## 2.1 消费端保持幂等性
    原因：重复发送消息
    消费端只消费一次
 
## 2.2 消费端幂等性保证
    解决方案：唯一id+指纹码，利用数据库主键去重
              利用redis的原子性去实现
#### 2.2.1 唯一id+指纹码，利用数据库主键去重
    好处：实现简单
    坏处：高并发下有数据库写入的性能瓶颈
    解决方案：跟进id进行分库分表进行路由算法
#### 2.2.2利用redis的原子性去实现
    1.是否需要入库，如果落库，数据库与缓存如何做到原子性。
    2.如果不进行· 落库，那么都存储到缓存中，如何设定定时同步策略
    
# 3.Confirm 确认消息实现
1.在channel上开启确认模式：channel.confirmSelect()

2.在channel上添加监听：addConfirmListener,监听失败和成功的结果，根据具体的结果对消息进行重新发送、或记录日志等后续处理。
# 4.Return消息机制
1.Return Listener 用于处理一些不可路由的消息

2.我们的消息生产者，通过制定的一个Exchange和RoutingKey,把消息送达到某一个队列中去，然后我们的消费者监听队列，进行消费处理操作

3.当前的exchange不存在或制定的路由key路由不到

4.Mandatory 为true,则监听器会收到路由不可达的消息，然后进行处理；false则删除消息。

